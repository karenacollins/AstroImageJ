//  The purpose of this AstroImageJ (AIJ) macro is to produce one or more of the following
//  three products that support the analysis of NEBs:
//  1.  The NEB Search Table. The macro will also compute the standard deviation in X and Y of image
//      shift for a given observation session. 
//  2.  A  plot of the relative, normalized flux of stars within a user-defined radius of a target,
//      overlayed with a plot of a transit showing the depth required for the star to cause the predicted
//      depth of the target.
//  3.  a  plot of dmag vs. unbinned RMS
//  The macro uses an AIJ measurement file, and optionally a plate-solved image to calculate the
//  pixel scale, as well as the PA's (for the NEB Search Table).
//
//  Comments or questions may be directed to the macro's author:
//  Dennis Conti, email: dennis@astrodennis.com
//
//  REVISION 1.8
var REVISION = "1.8";
//
//  The following are diagnostic flags
var STARtoDiagnose = "";
var FORCEbinning = 0;
//
//  Revision Notes:
//       1.8 Change the "Source-Sky per aperture pixel count" threshold test to <2 instead of <10;
//           enable "save plots to subfolder option" as the default; for an observation with a
//           negative Source-Sky value, set the dmag for the observation to 15; make a slight modification
//           to the note at the end of the dialogue page; added explanations of the two "Not Cleared" dispositions
//           at the bottom of the NEB table.
//       1.7 Combine dialogue messages to user at the end of each option into one message; establish a
//           a new disposition (Not cleared - flux too low) in the case where the (weighted) average Source-Sky pixel
//           count is < 10; change default radius search to 2.5 arc-minutes; moved selection of plots for
//           Option 2 under Option 2; change the way dmag is calculated - use the weighted mean across all
//           observations.
//       1.6 Add code to optionally store the individual NEB depth plots to a subdirectory as .png files
//       1.5 Make corrections for begin and end times for observations out of chronological order;
//           redo logic on determining if a day has rolled over
//       1.4 Add dmag to subtitle; have model depth change color based on disposition instead
//           of data points; change the formula for the NEB pred. depth; misc. other cosmetic changes
//       1.3 Took care of cases where observations are not in chronoloical order
//       1.2 Have Options 1-3 default to true; fix time plot when binning; misc. cosmetic changes
//       1.1 Rearrange user inputs for the various options
//       1.0 Initial Version
//
//                                     SET DEBUG MODE
//   0 = Logfile only contains status messages
//   1 = Debug values are used for all entries and Logfile contains detailed, intermittent information
//   2 = Print measurement file header keywords to logfile
var debugMode = 0;
//  
//                                   DEFINE GLOBAL VARIABLES
//
// Define special characters as global variables
var TAB = "\t";
var COMMA = ",";
var CR=fromCharCode(13)
var LF=fromCharCode(10);
//
// Define the output file  and path name as a global variable
var outputFile="";
var pathOutputFile="";
//
// Since functions only return a data value, globalValue is
// a global variable that can convey character strings from
// functions. Also define success  and useBJD as global values.
var globalValue="";
var success=false;
var useBJD = true;
//
//  Define other global variables
var xfitsTARGET = 0;
var yfitsTARGET = 0;
//
//                                    DEFINE FUNCTIONS
//
//  This function will output a message to the logfile if the
//  debugLevel passed to it is greater than or equal to the
//  debugMode that is set for this macro run
//
function debugPrint (message,debugLevel) {
    n=d2s(debugLevel,0);
    if (debugLevel <= debugMode) {print (message);};
    return(true);
};

//
//
//  This function posts an error message in the log window,
//  closes and deletes the open outputFile, and then exits.
//
function errorHandling (message) {
//  Print success message to dialogue
    Dialog.create("");
    Dialog.addMessage(message);
    Dialog.show();
    exit();
};

//
//
// This function validates that a string for a specified parameter
//  is less than or equal to a certain length.  If the length of the string
//  is valid, the function returns true; otherwise, the function produces
//  an error message and the macro is terminated.
//
function checkStringLength (parameter,string,length) {
    lenString=lengthOf(string);
    if (lenString<length+1) {
        return(true);
        } else {
        errorHandling ("**** ERROR: "+ parameter + " with a value of" + "'" + string + "'" + "is longer than allowed");
        }
};

//
//
// This function validates that a number for a specified parameter
//  is within a certain lower and upper range.  If the number
//  is valid, the function returns true; otherwise, the function produces
//  an error message and the macro is terminated.
//
function checkRange (parameter,number,lower,upper) {
    if ((number>lower||number==lower) && (number<upper||number==upper)) {
        return(true);
        } else {
       errorHandling ("**** ERROR: "+ parameter + " with a value of" + number + "is out of allowable range");
     };
};
//
//
//  This function creates, from a floating point value,
//  a right-justified character string
//  with a user-specified number of decimal digits
//
function rightJustify (value,digits) {
//  Convert value to a string and then back again in case the number of "digits" rounds it up
//  to another power of 10
     stringValue = d2s(value,digits);
     decimalValue = parseFloat(stringValue);
//  For values < 10, set numberDigits=1, otherwise find appropriate number of digits
     numberDigits = 1;
     while (decimalValue >= pow(10,numberDigits) ) {
         numberDigits = numberDigits + 1;
         };
//  If negative, account for minus sign
     if (decimalValue < 0) {numberDigits = numberDigits + 1;};
     message = "Value: " + decimalValue  +"   numberDigits: " + d2s(numberDigits,0);
     debugPrint(message,1);
//  Determine number of leading spaces are needed (up to 5)
     numberSpaces = 5-numberDigits;
     if (numberSpaces <= 0 ) {numberSpaces = 0;};
//  Add appropriate number of spaces to output string
     string = d2s(value,digits);
     for (i=1; i<numberSpaces; i++) {
         string = " " + string;
     };
     globalValue = string;
};

//
//
//  This function returns the modulus of a number for a given divisor
//
function modulus (value,divisor) {
     success = value/divisor - floor(value/divisor);
     return(success);
};

//
//
//  This function finds the position of a substring in a string
//   where items in the string are separated by
//   a delimiter.  If flag is true, then there is a non-empty
//   first position. If the substring is not found, then
//   success is returned as false and position=0.
//
function findPositionInHeader (string,substr,delimiter,flag) {
//  Find the beginning character position of a substring
//  in a string
    indexOfSubString=indexOf(string,substr);
    lastDelim=1;
    stringLength=lengthOf(string);
//  Set initial position
    if (flag) {
        position=0;
         } else {
        position=1;
    }
//  Loop through all instances of the delimiter in the string
//  until the one immediately after the substring is found
    for (i = 1; i<stringLength; i++) {
         nextDelim=indexOf(string,delimiter,lastDelim);
         if (nextDelim+1==indexOfSubString) {
             position=i+1;
             success=true;
             return(position);
         };
         lastDelim=nextDelim+1;
     }
    success=false;
    return(0);
};

//
//
//  This function finds the value at a certain position in a string
//   where the values are separated by a delimiter. This function
//   can be used in conjuntion with the above findPosition function
//   to having found the correct position of the value being searched for.
//   The value is stored in the global variable globalValue. The function
//   returns false if this is the last value found in the string.
//
function findValue (string,position,Delimiter) {
    nextDelim=-1;
    for (i = 0; i<position; i++) {
         lastDelim=nextDelim+1; 
         nextDelim=indexOf(string,Delimiter,lastDelim);
//  Check if this is the last item in the string
         if (nextDelim==-1) {
              globalValue=substring(string,lastDelim,lengthOf(string));
              return(false);
         }
    }
   globalValue=substring(string,lastDelim,nextDelim);
   return(true);
};

//
//
//  This function gets the value in a row of the user's data,
//   which value is associated with a particular parameter
//   (i.e., substring) in a header row. The position of the
//   parameter in the header row is first found, then the the corresponding
//   value in that position in the data row is found and returned. If column
//   flag (colflag) is true, then there is a label in col. 1
//   of the header row, otherwise there is not. If the parameter
//   is not found in the header, then success is returned as false.
//
function getData (searchString,headerString,rowString,delimiter,colflag) {
    position=findPositionInHeader(headerString,searchString,delimiter,colflag);
//  if the parameter was not found, then success is false and this is
//  returned by this function also as false.
    if (success) {success=findValue(rowString,position,delimiter);};
    return(success);
};

//
//
//   This function displays a string of a certain length as a user dialogue.
//   If debugMode is non-zero, a default value is displayed.
//
function userString (string,default,length) {
     Dialog.addString(string,default,length);
};

//
//
//  This function gets a user string in globalValue from the dialogue, and
//  checks if it is empty and the error message is NOT empty. If the latter
//  conditions are true, then an error message is printed and
//  the macro is terminated. Otherwise, a message is printed to the
//  log and a check is made of the string's length.
//
function getUserString (errorMessage,printMessage,length) {
     globalValue = Dialog.getString();
     if (globalValue == "" && errorMessage !="") {
         errorHandling("*** ERROR: " + errorMessage)};
     message = printMessage + globalValue;
     successPrint = debugPrint (message,1);
     checkStringLength (printMessage,globalValue,length);
};

//
//
//  This function returns the current observation time
//
function getObsTime (header,rowString,inputFileDelimiter,firstMeasTableColFlag) {
     if (useBJD) {
        success = getData("BJD_TDB",header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        } else {
               success = getData("JD_UTC",header,rowString,inputFileDelimiter,firstMeasTableColFlag);
               };
     observationTime = parseFloat(globalValue);
     return(observationTime);
};

//
//
//  This function computes the Y angle, namely the angle from Y through the target star
//  to the star in question, going in the direction from the Y+ axis in the direction
//  opposite to where the X+ axis is
//
function getYANGLE (X,Y) {
//  Case 1:  X < xfitsTARGET  and Y > yfitsTARGET
if (X <= xfitsTARGET && Y > yfitsTARGET) {
    Yangle = atan( (xfitsTARGET -X)/ (Y - yfitsTARGET)) * 180/PI;
    message = "Case 1:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 2:  X < xfitsTARGET  and Y < yfitsTARGET
if (X <= xfitsTARGET && Y <= yfitsTARGET) {
    Yangle = 90 + atan( (yfitsTARGET -Y)/ (xfitsTARGET -X)) * 180/PI;
    message = "Case 2:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 3:  X > xfitsTARGET  and Y < yfitsTARGET
if (X > xfitsTARGET && Y < yfitsTARGET) {
    Yangle = 270 - atan( (yfitsTARGET -Y)/ (X - xfitsTARGET)) * 180/PI;
    message = "Case 3:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 4:  X > xfitsTARGET  and Y > yfitsTARGET
if (X > xfitsTARGET && Y > yfitsTARGET) {
    Yangle = 270 + atan( (Y - yfitsTARGET)/ (X - xfitsTARGET)) * 180/PI;
    message = "Case 4:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 5:  X = xfitsTARGET  and Y > yfitsTARGET
if (X == xfitsTARGET && Y > yfitsTARGET) {
    Yangle = 0;
    message = "Case 5:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 6:  X = xfitsTARGET  and Y < yfitsTARGET
if (X == xfitsTARGET && Y < yfitsTARGET) {
    Yangle = 180;
    message = "Case 6:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 7:  X < xfitsTARGET  and Y = yfitsTARGET
if (X < xfitsTARGET && Y == yfitsTARGET) {
    Yangle = 90;
    message = "Case 7:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 8:  X > xfitsTARGET  and Y = yfitsTARGET
if (X > xfitsTARGET && Y == yfitsTARGET) {
    Yangle = 270;
    message = "Case 8:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
//  Case 9:  X = xfitsTARGET  and Y = yfitsTARGET
if (X == xfitsTARGET && Y == yfitsTARGET) {
    Yangle = 0;
    message = "Case 9:" + "X= " + d2s(X,5) + " Y= " + d2s(Y,5) + " Yangle= " + d2s(Yangle,5);
    debugPrint (message,1);
};
return(Yangle);
};

//
//  This function will find the (string) value associated with a keyword in a FIT header
//
function getFITstring(FITfile,keyword) {
   i = indexOf(FITfile,keyword);
   len = lengthOf(keyword);
   j = indexOf(FITfile,"=",i+len);
   k = indexOf(FITfile,"/",j+1);
   globalValue=substring(FITfile,j+1,k-1);
};

//
//
// The following are the valid lengths of user entries.
//  These are later used to perform range checks.
lenMeasurementTable = 3000;
lenTargetStar = 4;
lenIngressTime = 6;
lenEgressTime = 6;
lenTargetDepth = 6;
lenScale = 6;
lenRadius = 6;
lenRMSLimit = 3;
lenDistEvent = 6;
lenDeltaMag = 4;
lenPA = 5;
lenDirection = 15;
lenNEBSearchRow = 50;
lenTargetStar = 4;
lenRadius = 4;
lenCadence = 3;
singleQuote = fromCharCode(39);
doubleQuote = fromCharCode(34);
newlineChar = fromCharCode(10);
//
//
//****************** GET CURRENT DATE AND TIME FOR POSSIBLE FUTURE USE
//
getDateAndTime(year,month,dayOfWeek,dayOfMonth,hour,minute,second,msec);
//  Convert year, month, day, month, hour, and second to strings
yearString=d2s(year,0);
monthString=d2s(month+1,0);
// if month+1 is less than 10, append 0 as prefix - note month=0 is January
if (month+1<10) {
    monthString="0"+d2s(month+1,0);
    } else {
    monthString=d2s(month+1,0);
};
// if day is less than 10, append 0 as prefix
if (dayOfMonth<10) {
    dayString="0"+d2s(dayOfMonth,0);
    } else {
    dayString=d2s(dayOfMonth,0);
 };
hourString=d2s(hour,0);
minuteString=d2s(minute,0);
secondString=d2s(second,0);
datetime=yearString + "-" + monthString + "-" + dayString;
//
debugModeString = d2s(debugMode,0);
successPrint = debugPrint("Debug Mode="+ debugModeString,1);
//
//                               BEGIN USER DIALOGUES
//
//****************** CREATE THE FIRST PAGE OF USER DIALOGUES
//
Dialog.create("TFOP SG1 NEB Analysis Macro");

Dialog.addMessage("                     This macro creates a number of products that are helpful in analyzing potential NEBs.");
//
//  Select product(s) to be produced
Dialog.addMessage("Select one or more products that you would like to be produced:");
//  Option 1:
Dialog.addCheckbox("Option 1: A table showing which near-by stars are cleared as potential NEBs.",true);
//
//  Option 2:
Dialog.addCheckbox("Option 2: A plot for each near-by star's flux data with an overlay of NEB-required depth.",true);
//
Dialog.addCheckbox("                 Select here if you would like the Option 2 plots to be saved in a subfolder",true);
//
//  Option 3:
Dialog.addCheckbox("Option 3: A plot of Delta magnitude vs. RMS for all stars within a user-defined radius of a target star.",true);
//
//  Option 4:
Dialog.addCheckbox("Option 4: Same as Option 3, but plot log10 of RMS vs. simply RMS.",false);
Dialog.addMessage("");
//
//  Request name of target star that is in the measurement table header (e.g., T1)
string ="AIJ name of target star (e.g., T1)";
userString(string,"T1",lenTargetStar);
//
//  Ask for radius of interest
userString("Radius of interest around target (arc-min.)","2.5",lenRadius);
//
//  Request cadence
userString("Enter cadence to use when calculating RMS (seconds)","180",lenCadence);
//
//  Request user's preference for inputting pixel scale, or using a user-provided
//  plate-solved image to later calculate the PA's for the stars within the above
//  radius, as well as the pixel scale
Dialog.addCheckbox("Use plate-solved image to get pixel scale and, for Option 1, PA's",false);
Dialog.addString("If above is not selected, then enter the pixel scale (arc-sec/pixel)","",lenScale);
//
//  Request the predicted ingress time
string ="Predicted ingress time (decimal part only)";
userString(string,"",lenIngressTime);
//
//  Request the predicted egress time
string ="Predicted egress time (decimal part only)";
userString(string,"",lenEgressTime);
//
//  For Options 1 and 2, request the predicted depth of the target
string ="For Options 1 and 2: predicted depth of target star (ppt)";
userString(string,"",lenTargetDepth);
//
//  For Option 2, get multiple of RMS used to eliminate outliers
//  Set default RMS limit to rmsLimitValue
rmsLimitValue = 5;
userString("For Option 2: multiple of RMS used to eliminate outliers from plots",d2s(rmsLimitValue,0),lenRMSLimit);
//  Ask if the user would like to enable log file diagnostics
message = "Select this box if you would like to turn on logfile diagnostics";
Dialog.addMessage("");
Dialog.addCheckbox(message,false);
//
//  Ask user to open measurement file
Dialog.addMessage("");
Dialog.addMessage("After clicking OK, you will be asked to select the measurement file from which the table and/or plot(s) will be generated.");
//
Dialog.show();
//
//*****************  GET THE FIRST PAGE OF USE INPUTS
//
//  For Option 1:
nebTableOption = Dialog.getCheckbox();

//  For Option 2:
nebPlotOption = Dialog.getCheckbox();
//
//  Get choice of whether to save Option 2 plots to a subdirectory
savePlots = Dialog.getCheckbox();
if (savePlots && !nebPlotOption) {errorHandling("***** ERROR: Save plots option selected, but Option 2 was not selected");};
//
//  For Option 3:
dmagRMSOption = Dialog.getCheckbox();
//
//  For Option 4:
//  Get choice of log10 plot option for RMS
logPlot = Dialog.getCheckbox();
//  If the logPlot option chosen, also set dmagRMSOption to true
if (logPlot) {dmagRMSOption=true;};
//
//  Make sure at least one option was selected
if (!nebTableOption && !nebPlotOption && !dmagRMSOption && !logPlot) {errorHandling("**** ERROR: No option was selected");};
//
//  Get AIJ name of target star
getUserString ("No name of target star entered","Target star: ",lenTargetStar);
TARGET = globalValue;
//   Initialize various variables used later that are based on TARGET name
targetXFITString = "X(FITS)_" + TARGET;
targetYFITString = "Y(FITS)_" + TARGET;
//
//  Get radius of interest
getUserString ("No radius of interest entered","Radius of interest: ",lenRadius);
RADIUS = globalValue;
nRadius = parseFloat(RADIUS);
//
//  Get Cadence choice
getUserString("No RMS binning cadence entered","RMS binning cadence:",lenCadence);
CADENCE = globalValue;
requestedCadence = parseFloat(CADENCE);
//
//  Get choice of use of plate-solved image or not
usePlateSolvedImage = Dialog.getCheckbox();
SCALE = Dialog.getString();
if (usePlateSolvedImage && SCALE!="") {errorHandling("**** ERROR: Use of plate-solved image selected, but a non-zero pixel scale also entered.");};
if (!usePlateSolvedImage && SCALE=="") {errorHandling("**** ERROR: No pixel scale was entered.");};
//  If use of plate-solved image was not seleted, convert pixel scale to a number
if (!usePlateSolvedImage) {nScale=parseFloat(SCALE);};
//
//  Get predicted ingress time
getUserString("No predicted ingress time entered","Pred. ingress time:",lenIngressTime);
INGRESS = globalValue;
ingressTime = parseFloat(INGRESS);
//
//  Get predicted egress time
getUserString("No predicted egress time entered","Pred. egress time:",lenEgressTime);
EGRESS = globalValue;
egressTime = parseFloat(EGRESS);
//  Check that ingressTime is less than egressTime
if (ingressTime >= egressTime) {errorHandling("****ERROR - ingress time is greater than or equal to egress time");};
//
//  For Options 1 and 2, get predicted target depth
DEPTH = Dialog.getString();
if ((nebTableOption || nebPlotOption) && DEPTH=="") {errorHandling("**** ERROR: Option 1 or 2 was selected, but no predicted target depth was entered");};
predTargetDepth = parseFloat(DEPTH);
//
//  For Option 2, get multiple of rms used to eliminate outliers
RMSlimit = Dialog.getString();
if (nebPlotOption && RMSlimit == "") {errorHandling("**** ERROR: Option 2 was selected, but no multiple of RMS was entered");};
if (nebPlotOption && RMSlimit != "") {rmsLimitValue = parseFloat(RMSlimit);};
//
//  Get choice of debug mode and, if enabled, clear the log window
debugChoice = Dialog.getCheckbox();
if (debugChoice) {
   debugMode=1;
//  Clear the user's AIJ log window
   print("\\Clear");
};
//
//
//****************** GET MEASUREMENT TABLE
//
// Set firstMeasTableColFlag to false indicating that the first column of the measurement
// table header does not contains a label
firstMeasTableColFlag = false;
successPrint = debugPrint("First measurement table col. flag: " + firstMeasTableColFlag,1);
//
//  Open the user-specified measurement file and then put the file into an array by rows
//
filepath = File.openDialog("Select AIJ Measurements Table");
measurementFile = File.openAsString(filepath);
measurementFileName = File.nameWithoutExtension;
fileSeparator = File.separator;
successPrint = debugPrint("Successfully retrieved measurement file" + measurementFileName + " with a file separator of: " + fileSeparator,1);
//
//  Get directory of the user's measurement file
fileDir= File.directory;
success = debugPrint("Output file for any NEB table to be stored in: ",fileDir);
//
//  Determine delimiter (tab or comma) used in the
//  input measurement table and set inputFileDelimiter
//  to this.
//
fullFileName = File.name;
indexOfperiod = lastIndexOf(fullFileName,".");
extension = substring(fullFileName,indexOfperiod+1);
message = "Extension= " + extension;
debugPrint(message,1);
if (extension == "tbl" || extension == "txt" || extension == "xls") {
    inputFileDelimiter = TAB;
    } else {
           if (extension == "csv") {
               inputFileDelimiter = COMMA;
               } else {errorHandling("*** ERROR: file extension is not .tbl, .txt, .xls, or .csv");};
           };
//  Split the measurement file into an array
fileArray=split(measurementFile,"\n");
nRows=lengthOf(fileArray);
//  Calculate number of observations
nObservations = nRows - 1;
success = debugPrint("No. of observations: " + d2s(nObservations,0),1); 
//  Check if size of measurment table is less than 3,000 rows
if (nRows > lenMeasurementTable) {
     errorHandling("*** ERROR: Measurement table exceeds 3,000 rows")};
//  Get header row
header=fileArray[0];
//
//
//  If the first col. of the header does not contain a label,
//  then set iStart =2
if (firstMeasTableColFlag) {
     iStart = 1;} else {iStart = 2;};
//
//
//****************** OPTIONALLY, CREATE THE DIALOGUE PAGE THAT REQUESTS THE PLATE-SOLVED IMAGE
//                   AND THEN EXTRACT THE PERTINENT DATA FROM THE *.FIT FILE
//
if (usePlateSolvedImage) {
    Dialog.create("");
    Dialog.addMessage("After clicking OK, you will be asked to select a plate-solved file associated with this observation.");
    Dialog.show();
//
//  Get the user's plate-solved file and extract the necessary WCS keyword values
//
//  Read plate-solved file
//
    filepath = File.openDialog("Select Plate Solved File");
    fitFile=File.openAsRawString(filepath,20000);
    debugPrint("Successfully retrieved plate-solved file",1);
//
//   Find value for WCS parameter CD1_1
    getFITstring (fitFile,"CD1_1");
    CD11string = globalValue;
    CD11 = parseFloat(CD11string);
    message = "CD1_1=" + CD11string;
    debugPrint(message,1);
//
//   Find value for WCS parameter CD1_2
    getFITstring (fitFile,"CD1_2");
    CD12string = globalValue;
    CD12 = parseFloat(CD12string);
    message = "CD1_2=" + CD12string;
    debugPrint(message,1);
//
//   Find value for WCS parameter CD2_1
    getFITstring (fitFile,"CD2_1");
    CD21string = globalValue;
    CD21 = parseFloat(CD21string);
    message = "CD2_1=" + CD21string;
    debugPrint(message,1);
//
//   Find value for WCS parameter CD2_2
    getFITstring (fitFile,"CD2_2");
    CD22string = globalValue;
    CD22 = parseFloat(CD22string);
    message = "CD2_2=" + CD22string;
    debugPrint(message,1);
//
//  Compute orientation
    det = CD11*CD22 - CD12*CD21;
    if (det >= 0) {parity=1.0;} else {parity =-1.0;};
    T = parity * CD11 + CD22;
    A = parity * CD21 - CD12;
//   Orientation = 0 to 180 deg for Y axis clockwise from North, and
//   0 to -180 deg for Y axis counter-clockwise from North
    orient = -atan2(A,T) *180 / PI;
    message = "Orientation= " + d2s(orient,5) +" degrees";
    debugPrint(message,1);
//  Convert orientation angle to rotation angle (i.e., 0 to 360 deg)
    if (orient > 0) {rotation = orient;} else {rotation = 360 + orient;};
    message = "Rotation = " + d2s(rotation,5);
    debugPrint(message,1);
//
//  Compute scale and convert to arc-seconds
    nScale = sqrt(CD11*CD11 + CD12*CD12) * 3600;
    SCALE = d2s(nScale,5);
    message = "Scale= " + SCALE;
    debugPrint(message,1);
//
//  Determine orientation of Y/X axis to N/E. The orientation is determined
//  by different combinations of CD1_1, CD1_2, CD2_1, and CD2_2. The sign
//  of these CD values determine different orientations of RA and DEC to
//  different orientations of X and Y, as follows:
//   +CD1_1  X values increase as East values increase
//   -CD1_1: X values decrease as East values increase
//   +CD1_2: Y values increase as East values increase
//   -CD1_2: Y values decrease as East values increase
//   +CD2_1  X values increase as North values increase
//   -CD2_1: X values decrease as North values increase
//   +CD2_2: Y values increase as North values increase
//   -CD2_2: Y values decrease as North values increase
//  The following are the two orientations to be considered:
//       Orientation 1:             Orientation 2:
//        N          Y         N                 Y
//        |          |         |                 |
//        |          |         |                 |
//        +-----E    +-----X   +-----E     E-----+
//
//   The following CD combination are indicative of either Orientation 1 or 2, where 0
//  indicates a "-" sign and 1 indicates a "+" sign. Each combination can thus be represented
//  by a unique 4-bit number, i.e., by a number from 0-15:
//     For Orientation 1:
//       CD1_1    CD1_2    C2_1    CD2_2  Unique Number Representation
//         1        1        0       1                13
//         0        1        0       0                 4
//         0        0        1       0                 2 
//         1        0        1       1                11
//     For Orientation 2:
//         0        1        1       1                 7
//         1        1        1       0                14
//         1        0        0       0                 8
//         0        0        0       1                 1
//  Determination orientation number of image
//  First determine sign of CD values
    if (CD11 > 0) {signCD11=1;} else {signCD11 = 0;};
    if (CD12 > 0) {signCD12=1;} else {signCD12 = 0;};
    if (CD21 > 0) {signCD21=1;} else {signCD21 = 0;};
    if (CD22 > 0) {signCD22=1;} else {signCD22 = 0;};
    orientationNumberOfImage = signCD11*pow(2,3) + signCD12*pow(2,2) + signCD21*pow(2,1) + signCD22*pow(2,0);
    message = "Orientation number of Image: " + d2s(orientationNumberOfImage,5);
    debugPrint(message,1);
//  Determine from above table, orientation type (i.e., 1 or 2)
    n = orientationNumberOfImage;
    if (n==13 || n==4 || n==2 || n==11) {
        orientationType = 1;
        } else {
               if (n==7 || n==14 || n==8 || n==1) {
                   orientationType = 2;
                   } else {
                          print("****** ERROR: Invalid orientation");
                          exit();
                          };
               };
    message = "Orientation type: " + d2s(orientationType,0);
    debugPrint(message,1);
};
//
//************ BEGIN PROCESSING OF MEASUREMENT TABLE DATA
//
//************ Get a list of all stars in the measurement table
//
//  Cycle through header parameters and store star IDs in xfitsList
//  if they have an X(FITS) value.
//  First initialize xfitsList array
//
xfitsList=newArray(1000);
xfitsListIndex = 0;
success=true;
successPrint = debugPrint(" ",1);
successPrint = debugPrint("The following are the measurement table header keywords",2);
for (i=iStart; i<lengthOf(header)&&success;i++) {
     success=findValue(header,i,inputFileDelimiter);
     if (success) {
        successPrint = debugPrint(globalValue,2);
//  Check if found a target or comp XFITS() coordinate;
//  find X(FITS)_XXX headers - note, need to eliminate X(FITS) header
        if (substring(globalValue,0,2) == "X(" && lengthOf(globalValue) > 7) {
           if (substring(globalValue,0,5) == "X(FIT") {
              starID = substring(globalValue,8);
              successPrint = debugPrint("starID: " + starID,1);
              xfitsList[xfitsListIndex] = starID;
              xfitsListIndex = xfitsListIndex + 1;
//  Check if have found over 1,000 stars
              if (xfitsListIndex == 1000) {errorHandling("**** ERROR: number of stars is greater than 1000");};
            };
         };
     };
};
successPrint = debugPrint(" ",1);
//
//
//
//
//****************** CYCLE THROUGH ALL STARS TO SEE WHICH ONES ARE
//                   WITHIN THE PRESCRIBED DISTANCE OF THE TARGET STAR,
//                   AND FOR THOSE THAT ARE,(OPTIONALLY) COMPUTE THEIR PA
//
//   Setup various STAR arrays
STARlist = newArray(1000);
STARdist = newArray(1000);
STARpa = newArray(1000);
//
//  Get XFITS, YFITS values for the target star 
STARlistIndex = 0;
//  Compute radius of interest in pixels
distanceLimit = nRadius*60 / nScale;
rowString = fileArray[1];
success=getData(targetXFITString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
if (!success) {errorHandling ("***ERROR: No X(FITS) value for target star");}; 
xfitsTARGET = parseFloat(globalValue);
success=getData(targetYFITString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
if (!success) {errorHandling ("***ERROR: No Y(FITS) value for target star");}; 
yfitsTARGET = parseFloat(globalValue);
successPrint = debugPrint ("xfitsTARGET=" + xfitsTARGET,1);
successPrint = debugPrint ("yfitsTARGET=" + yfitsTARGET,1);
//  Cycle through the stars in xfitsList to see which ones are within
//  the distanceLimit of the target star
for (j = 0; j<xfitsListIndex; j++) {
//  Get the X(FITS) and Y(FITS) location of star
     starID = xfitsList[j];
     successPrint = debugPrint("check: " + starID,1);
     starXFITSString = "X(FITS)_" + starID;
     starYFITSString = "Y(FITS)_" + starID;
     success=getData(starXFITSString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
     xfitSTAR = parseFloat(globalValue);
     success=getData(starYFITSString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
     yfitSTAR = parseFloat(globalValue);
     valdist = (xfitsTARGET-xfitSTAR)*(xfitsTARGET-xfitSTAR) + (yfitsTARGET-yfitSTAR)*(yfitsTARGET-yfitSTAR);
     distanceToTarget = sqrt(valdist);
     successPrint = debugPrint("xfitsTARGET=" + xfitsTARGET + "   xfitSTAR=" + xfitSTAR + "   yfitsTARGET=" + yfitsTARGET + "  yfitSTAR=" +yfitSTAR,1);
     successPrint = debugPrint("distanceToTarget (pixels) = " + distanceToTarget,1);
//  If the star is within the prescribed distance from the target, include the star in the STARlist array
     if (distanceToTarget <= distanceLimit) {
         STARlist[STARlistIndex] = starID;
         successPrint = debugPrint("Include: " + STARlist[STARlistIndex] + " at a distance of " + d2s(distanceToTarget/nScale,2) + " arc-seconds",1);
         STARdist[STARlistIndex] = distanceToTarget * nScale;
         successPrint = debugPrint("STARlist value= " + STARlist[STARlistIndex] + "STARdist value= " + STARdist[STARlistIndex],1);
//
// Compute PA if user selected use of a plate-solved image
         if (usePlateSolvedImage) {
// Compute Y angle
            Yangle = getYANGLE (xfitSTAR,yfitSTAR);
            message = "xfitSTAR= " + d2s(xfitSTAR,5) + " yfitSTAR= " + d2s(yfitSTAR,5) + "Yangle= " + d2s(Yangle,5);
            debugPrint(message,1);
//
// Based on the Orientation, and Yangle and rotation values, compute the Position Angle (PA)
//
// Orientation 1:
            if (orientationType == 1) {
               if (Yangle >= rotation) {
                   PA = 360 - Yangle + rotation;} else {PA = rotation - Yangle;};
                   };
//  Orientation 2:
            if (orientationType ==2) {
               if (Yangle+rotation <= 360) {
                   PA = Yangle + rotation;} else {PA = rotation + Yangle -360;};
                   };
//   Store PA for this star in the STARpa array
            message = "PA: " + d2s(PA,1);
            debugPrint(message,1);
            STARpa[STARlistIndex] = PA;
        };
         STARlistIndex = STARlistIndex + 1;
         };
};
successPrint = debugPrint(" ",1);
//
//
//****************** CYCLE THROUGH ALL OBSERVATIONS TO:
//                   1. COMPUTE AVERAGE SOURCE-SKY
//                   2. COMPUTE AVERAGE DMAG
//                   3. COMPUTE AVERAGE APERTURE SIZE
//                   4. STORE THE OBSERVATION TIMES
//
//  For the observation times, first determine if BJD+TDB is in the measurement table.
//  If not, use JD_UTC. Then, for each observation, compute the right side of each observation
//  time and store it in obsTimesRight array; check if need to add 1 if the day rolls over.
//  Also, store the beginTime, endTime, and their right sides for later use in determining
//  the overlap case
//
rowString = fileArray[1];
success = getData("BJD_TDB",header,rowString,inputFileDelimiter,firstMeasTableColFlag);
//  Set useBJD to true if BJD_TDB is used and there is BJD_TDB data, otherwise set useBJD to false
//  if JD_UTC is used and there is JD_UTC data
timeValue = parseFloat(globalValue);
if (success && timeValue>0) {
   useBJD = true;
   } else {
          success = getData("JD_UTC",header,rowString,inputFileDelimiter,firstMeasTableColFlag);
          if (!success || timeValue <=0) (errorHandling("**** ERROR - neither BJD_TDB or JD_UTC times were in measurement file.");
          useBJD = false;
          };
success = debugPrint("useBJD = " + useBJD,1);
//
//  Create an array of observation times to be later sorted
obsTimesArray = newArray(nObservations);
obsTimesRight = newArray(nObservations);
prevObsTimeLeft = 0.0;
//  Create average arrays for Source-Sky and Dmag
STARsourceAvg = newArray(1000);
STARdmagAvg = newArray(1000);
//  Initialize averages
Array.fill(STARsourceAvg,0.0);
Array.fill(STARdmagAvg,0.0);
averageAPERTURE = 0.0;
for (i=1; i<nObservations+1; i++) {
    rowString = fileArray[i];
//  Get the Source_Radius and add it to the running count of averageAperture
    success=getData("Source_Radius",header,rowString,inputFileDelimiter,firstMeasTableColFlag);
    if (!success) {errorHandling ("***ERROR: No Source_Radius value for the observation");};
    averageAPERTURE = averageAPERTURE + parseFloat(globalValue);
//  Get the Source-Sky (i.e., flux) value of the target for later use in computing the average Source-Sky
//  and Dmag's of each star
    targetSourceSkyString = "Source-Sky_" + TARGET;
    success=getData(targetSourceSkyString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
    fluxTarget = parseFloat(globalValue);
    message = "For Observation: " + i + "Target Source-Sky= " + targetSourceSkyString + "=" + globalValue;
    successPrint = debugPrint(message,1);
//  Cycle through all stars in STARlist and compute their running average for Source-Sky and Dmag
    for (k=0;k<STARlistIndex;k++) {
//  Get the Source-Sky value of the star for the current observation
         starID = STARlist[k];
         SourceSkyString = "Source-Sky_" + starID;
         success=getData(SourceSkyString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
         fluxStar = parseFloat(globalValue);
//  Compute the running average for Source-Sky
         STARsourceAvg[k] = STARsourceAvg[k] + fluxStar/nObservations;
//  If Source-Sky is negative, set dmag=15
         if (fluxStar < 0) {
            dmag = 15;
            } else {
//  Else, compute the dmag of the star relative to the target
//  Use natural log (base e) - but, log10(n) = log(n)/log(10)
                   dmag = -2.5 * log(fluxStar/fluxTarget)/log(10);
                   };
//  Compute the running average for Dmag
         STARdmagAvg[k] = STARdmagAvg[k] + dmag/nObservations;
         dmagString = d2s(dmag,2);
         successPrint = debugPrint("Dmag for " + starID + "=" + dmagString,1);
    }; 
//
//  Get time of observation and store it in obsTimesArray for later use
    obsTimesArray[i-1] = getObsTime(header,rowString,inputFileDelimiter,firstMeasTableColFlag);
};
//
//  Finish computing the average aperture and convert to arc-seconds
averageAPERTURE = averageAPERTURE / nObservations;
averageAPERTUREarcseconds = averageAPERTURE * nScale;
//  Area of average aperture
apertureArea = PI*averageAPERTURE*averageAPERTURE;
successPrint = debugPrint(" ",1);
message = "Average Aperture (pixels): " + d2s(averageAPERTURE,1) + " Average Aperture (arc-seconds): " + d2s(averageAPERTUREarcseconds,1) + " Aperture area: " + d2s(apertureArea,4);
successPrint = debugPrint(message,1);
//
//
//******************  COMPUTE THE WEIGHTED AVERAGES FOR SOURCE-SKY AND DMAG
//
//  Create arrays for Source-Sky and Dmag
STARSourceSky = newArray(3000);
STARdmag = newArray(3000);
//  For each star, cycle through all the observations
for (k=0;k<STARlistIndex;k++) {
    avgSource = STARsourceAvg[k];
    avgDmag = STARdmagAvg[k];
    message = "For Star: " + STARlist[k] + " average Source-sky= " + d2s(avgSource,2) + " average dmag= " + d2s(avgDmag,2);
    success = debugPrint(message,1);
//  Zero-out running amounts
    sourceDenominator = 0.0;
    sourceNumerator = 0.0;
    dmagDenominator = 0.0;
    dmagNumerator = 0.0;
    for (i=1;i<nObservations+1;i++) {
        rowString = fileArray[i];
//  Get the Source-Sky value of the star for the current observation and
//  compute the current sourceWeight value
        starID = STARlist[k];
        SourceSkyString = "Source-Sky_" + starID;
        success=getData(SourceSkyString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        fluxStar = parseFloat(globalValue);
//  If fluxStar = avgSource, bypass including this measurement in the weighted avaerage
        if (fluxStar != avgSource) {
           sigmaSquared = (fluxStar - avgSource) * (fluxStar - avgSource);
//  Compute running sum of 1/sigmaSquared;
           sourceDenominator = sourceDenominator + 1/sigmaSquared;
//  Compute running sum of Source-Sky/sigmaSquared for Source-Sky
           sourceNumerator = sourceNumerator + fluxStar/sigmaSquared;
           };
//  Get the Source-Sky value of the target star and compute the
//  current dmag and then the current sourceDmag value
        targetSourceSkyString = "Source-Sky_" + TARGET;
        success=getData(targetSourceSkyString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        fluxTarget = parseFloat(globalValue);
//  If Source-Sky is negative, set dmag=15
        if (fluxStar < 0) {
           dmag = 15;
           } else {
                  dmag = -2.5 * log(fluxStar/fluxTarget)/log(10);
                  };
//  If dmag = avgDmag, bypass including this measurement in the weighted average
        if (dmag != avgDmag) {
           sigmaSquared = (dmag - avgDmag) * (dmag - avgDmag);
//  Compute running sum of 1/sigmaSquared for dmag
           dmagDenominator = dmagDenominator + 1/sigmaSquared;
//  Compute running sum of dmag/sigmaSquared for dmag
           dmagNumerator = dmagNumerator + dmag/sigmaSquared; 
        };
    };
//  Compute the Source-Sky and Dmag weighted averages
//  In the case where all the Source-Sky's were all the same (although unlikely),
//  set STARSourceSky = fluxStar, i.e., the last measure in the table;
//  otherwise compute the weighted average as normal
    if (sourceNumerator == 0.0) {
       STARSourceSky[k] = fluxStar;
       } else {STARSourceSky[k] = sourceNumerator/sourceDenominator;};
//  In the case where all dmag's were the same (which would occur with the TARGET),
//  set STARdmag = dmag, i.e., the last computation of dmag (note, for the TARGET,
//  this should be 0.0); otherwise compute the weighted average as normal
    if (dmagNumerator == 0.0) {
        STARdmag[k] = dmag;
        } else {STARdmag[k] = dmagNumerator/dmagDenominator;};
};
//
//******************  SORT THE OBSERVATION TIMES AND GET THE BEGINNING AND END TIMES
//
Array.sort(obsTimesArray);
//  Compute the right side of each observation time and store them in obsTimesRight array. Check if day
//  rolls over, and if so, add 1
for (i=0; i<nObservations; i++) {
    obsTime = obsTimesArray[i];
//  Get left and right side of the decimal point
    obsTimeLeft = floor(obsTime);
    obsTimeRight = obsTime - obsTimeLeft;
//  Add 1.0 if the day had rolled over
    if (obsTimeLeft == prevObsTimeLeft + 1) {obsTimeRight = obsTimeRight +1;};
    prevObsTimeLeft = obsTimeLeft;
//  Store obsTimeRight in obsTimesRight array
    obsTimesRight[i] = obsTimeRight;
};
beginTime = obsTimesArray[0];
beginTimeRight = obsTimesRight[0];
//  Compute beginTimeLeft for later use in the X-axis legend of the Option 2 plots
beginTimeLeft = floor(beginTime);
message = "Begin time: " + beginTime + "  Begin time right: " + d2s(beginTimeRight,12);
success = debugPrint(message,1);
endTime = obsTimesArray[nObservations-1];
endTimeRight = obsTimesRight[nObservations-1];
message = "End time: " + endTime + "  End time right: " + d2s(endTimeRight,12);
success = debugPrint(message,1);
//  Compute total observation time
observationDuration = (endTime - beginTime)*24*60;
message = "Duration of observation (minutes): " + d2s(observationDuration,2);
success = debugPrint(message,1);
//
//
//****************** DETERMINE OVERLAP CASE FOR ALL OPTIONS
//
overlapCase = true;
//  If the observation is entirely within the predicted transit duration
//  and therefore there is no OOT observation data, set overlapCase to false
if ( (beginTimeRight<ingressTime && endTimeRight<ingressTime) || (beginTimeRight>egressTime && endTimeRight>egressTime)
  || (beginTimeRight>ingressTime && endTimeRight<egressTime) )
     {overlapCase = false;};
success = debugPrint("overlapCase= " + overlapCase,1);
//
//
//****************** COMPUTE BINNING VALUE FOR ALL OPTIONS
//
//  Compute average cadence in the observation (in seconds)
averageExpPlusDelay = observationDuration*60/(nObservations);
binning = floor(requestedCadence/averageExpPlusDelay);
if (binning < 1) {binning = 1;};
if (FORCEbinning > 0) {binning = FORCEbinning;};
message = "Avg. exposure plus delay (sec): " + d2s(averageExpPlusDelay,2) + "   binning: " + d2s(binning,0);
debugPrint(message,1);
//
//
//****************** CREATE AN INDEX ARRAY THAT POINTS TO THE MEASUREMENT TABLE RECORDS
//                   IN CHRONOLOGICAL ORDER
//
indexArray = newArray(nObservations);
for (i=1;i<nObservations+1;i++) {
};
// For each time value in obsTimesArray, find the corresponding row in the measurement
// table and store the measurement table row number into the indexArray
for (j=0;j<nObservations;j++) {
    for (i=1;i<nObservations+1;i++) {
        rowString = fileArray[i];
        obsTime = getObsTime(header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        if (obsTimesArray[j] == obsTime) {
           indexArray[j] = i;
//  End i Loop
           i = nObservations;
           }; 
        };
};
if (debugMode == 1) {
   print("Mapping:");
   for (i=1;i<nObservations+1;i++) {
       index = indexArray[i-1];
       print("index: ",index);
       rowString = fileArray[index];
       DateString = "BJD_TDB";
       success = getData(DateString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
       print("i: ",i," index: ",index," date: ",globalValue);
   };
};
//
//
//****************** CREATE ARRAYS OF BINNED INFORMATION FOR
//                   ALL STARS THAT ARE IN STARlist FOR LATER USE
//
//  Create arrays for holding binned information for all stars for future use
binnedRelFlux = newArray(nObservations*STARlistIndex);
binnedRelFluxErr = newArray(nObservations*STARlistIndex);
//
//  Create arrays for temporarily holding cumulative binned data
//  and initially zero them out
STARtempBinFlux = newArray(3000);
STARtempBinErr = newArray(3000);
Array.fill(STARtempBinFlux,0.0);
Array.fill(STARtempBinErr,0.0);
//  When loop below is completed, binCount will be the total number of bins
//  for all stars, and nBins will be the number of bins for each star
binCount = 0;
//
//  Cycle through all stars
for (k=0; k<STARlistIndex;k++) {
    successPrint = debugPrint(" ",1);
    message = "For star " + STARlist[k] + ":";
    successPrint = debugPrint(message,1);
//  Keep track of number of bins and number of entries computed so far for
//  the current bin
    nBins = 0;
    nBinEntries = 0;
    for (i=1; i<nObservations+1; i++) {
//  Get index into measurement table for measurements increasing in chronological order
        index = indexArray[i-1];
        rowString = fileArray[index];
        RelFluxString = "rel_flux_" + STARlist[k];
        success = getData(RelFluxString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        relflux = parseFloat(globalValue);
        RelFluxErrString = "rel_flux_err_" + STARlist[k];
        success = getData(RelFluxErrString,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
        relfluxerr = parseFloat(globalValue);
        message = "   rel_flux: " + d2s(relflux,6) + " rel_flux_err: " + d2s(relfluxerr,6);
        if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
        if (modulus(i,binning) == 0) {
//  Add binned rel_flux and rel_flux_err values into their respective arrays
           binnedRelFlux[binCount] = (relflux + STARtempBinFlux[k])/binning;
           binnedRelFluxErr[binCount] = sqrt(relfluxerr*relfluxerr + STARtempBinErr[k])/binning;
           message = "   binned rel_flux: " + d2s(binnedRelFlux[binCount],6) + " binned rel_flux_err: " + d2s(binnedRelFluxErr[binCount],6);
           if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
           binCount = binCount +1;
           nBins = nBins + 1;
//  Reinitialize temporary binning array values to 0.0
           STARtempBinFlux[k] = 0.0;
           STARtempBinErr[k] = 0.0;
//  Reset number of entries computed so far for the current bin
           nBinEntries = 0;     
           } else {
                  STARtempBinFlux[k] = STARtempBinFlux[k] + relflux;
                  STARtempBinErr[k] = STARtempBinErr[k] + relfluxerr*relfluxerr;
//  Track current number of bin entries
                  nBinEntries = nBinEntries + 1;
                  };
     };
//  If there are still some unbinned remaining observations, compute their binned value and add them
//  to their respective arrays
    if (nBinEntries != 0) {
//  Add binned rel_flux and rel_flux_err values into their respective arrays
        binnedRelFlux[binCount] = STARtempBinFlux[k]/nBinEntries;
        binnedRelFluxErr[binCount] = sqrt(STARtempBinErr[k])/nBinEntries;
        message = " For the remaining " + d2s(nBinEntries,0) + " bin entries: binned rel_flux= " + d2s(binnedRelFlux[binCount],6) + " binned rel_flux_err= " + d2s(binnedRelFluxErr[binCount],6);
        if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
        binCount = binCount + 1;
        nBins = nBins + 1;
        }; 
};
message = "Total binCount= " + binCount + "Number of bins for each star: " + nBins;
successPrint = debugPrint(message,1);
//
//
//****************** CALCULATE BINNED TIME STAMPS
//
STARtempBinnedTime = 0.0;
binnedObsTimes = newArray(nObservations);
successPrint = debugPrint(" ",1);
binTimeCount = 0;
for (i=1; i<nObservations+1; i++) {
    if (modulus(i,binning) == 0) {
//  Add binned observation time into the binnedTime array
        binnedObsTimes[binTimeCount] = (obsTimesRight[i-1] + STARtempBinnedTime)/binning;
        message = "For observation: " + i + " binned observ. time= " + d2s(binnedObsTimes[binTimeCount],7);
        successPrint = debugPrint(message,1);
        binTimeCount = binTimeCount + 1;
        nBinEntries = 0;
        STARtempBinnedTime = 0.0;
        } else {
               STARtempBinnedTime = STARtempBinnedTime + obsTimesRight[i-1];
               nBinEntries = nBinEntries + 1;
               };
};
//  If there are still some unbinned remaining observations, compute their binned time
//  value and add them to the binnedObsTimes arrays
    if (nBinEntries != 0) {
        binnedObsTimes[binTimeCount] = STARtempBinnedTime/nBinEntries;
        message = " For the remaining " + d2s(nBinEntries,0) + " bin entries: binmed time " + d2s(binnedObsTimes[binTimeCount],7);
        successPrint = debugPrint(message,1);
        binTimeCount = binTimeCount + 1;
        }; 
//
//
//****************** COMPUTE THE WEIGHTED AVERAGES FOR (binned) REL_FLUX FOR EACH STAR in STARlist
//
//  The weighted average for rel_flux will be used for later use in computing its relative, normalized flux.
//  For rel_flux, include only OOT data in computing the average, unless the observation
//  is completely outside or completely inside the predicted transit in which case all data is used.
//
STARweightedFluxAvg = newArray(1000);
successPrint = debugPrint(" ",1);
successPrint = debugPrint("*****************  Computation of running weighted averages ****************",1);
for (k=0; k<STARlistIndex; k++) {
    numeratorSum = 0.0;
    denominatorSum = 0.0;
//  Cycle through all binned observations and compute, for those to be included, calculate the
//  the running sum of invVar = 1/relfluxerr^2, where relfluxerr = the rel_flux error for the star for the
//  observation, as well as the running sum of the rel_flux * invVar. The weighted, normalized average
//  is then the latter divided by the former
    iBegin = k*nBins;
    iEnd = (k+1)*nBins;
    iTime = 0;
    for (i=iBegin; i<iEnd;i++) {
//  If the observation is OOT, include it in running average. However, if the observation
//  is completely within the predicted transit, include it as well
        obsTime = binnedObsTimes[iTime];
        iTime = iTime + 1;
        if (obsTime<ingressTime || obsTime>egressTime || !overlapCase) {
           obsTimeString = d2s(obsTime,15);
           message = "Observation time: " + obsTimeString;
           if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
//  Get star's rel_flux
           RelFluxString = "rel_flux_" + STARlist[k];
           relflux = binnedRelFlux[i];
           message = "For bin " + i + ": " + RelFluxString + "=" +  d2s(relflux,6);
//  Get star's rel_flux_err
           RelFluxErrString = "rel_flux_err_" + STARlist[k];
           relfluxerr = binnedRelFluxErr[i];
           message = message + "  " + RelFluxErrString + "=" +  d2s(relfluxerr,6);
           if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
//  Compute a running sum of invVar and rel_flux * invVar
           invVar = 1/(relfluxerr*relfluxerr);
           denominatorSum = denominatorSum + invVar;
           relfluxTimesinvVar = relflux * invVar;
           numeratorSum = numeratorSum + relfluxTimesinvVar;
           message = "invVar= " + invVar + " denominatorSum=" + denominatorSum + "relflx times invVar=" + relfluxTimesinvVar + " numeratorSum=" + numeratorSum;
           if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
           };
    };
//  Compute the weighted average for each star
    STARweightedFluxAvg[k] = numeratorSum / denominatorSum;
    message = "Normalized weighted avg for " + STARlist[k] + "=" + STARweightedFluxAvg[k];
    if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
    successPrint = debugPrint(" ",1);
};
//
////****************** COMPUTE THE RELATIVE, NORMALIZED FLUX OF EACH STAR IN STARlist
//
//  For each star in STARlist, cycle through each row in the measurement table
//  and compute its relative, normalized flux. Also, compute a running average
//  for later use in computing the RMS. Since the macros don't support two-
//  dimensional arrays, store in normalizedFlux the values for the observations
//  for all stars. The beginning of each list for star with index k is indexed
//  into normalizedFlux by k*nBins. STARlistIndex = number of stars in
//  STARlist. When done, nValues will equal the number of normalized flux values.
//
normalizedFlux = newArray(nBins*STARlistIndex);
avgNormFlux = newArray(STARlistIndex);
nValues = 0;
for (k=0; k<STARlistIndex; k++) {
    runningAverage = 0.0;
    iBegin = k*nBins;
    iEnd = (k+1)*nBins;
    message = "For star " + STARlist[k] + ":";
    if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
    for (i=iBegin; i<iEnd;i++) {
        successPrint = debugPrint(" ",1);
        iString = d2s(i,0);
        message = "For observation " + iString + ":";
        if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
//  Get the rel_flux of the star
        RelFluxString = "rel_flux_" + STARlist[k];
        relflux = binnedRelFlux[i];
        relfluxString = d2s(relflux,6);
        message = "relflux for: " + STARlist[k] + "=" + relfluxString;
        if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
//  Compute normalized flux
        normalizedFlux[nValues] = relflux/STARweightedFluxAvg[k];
//  Compute running average
        runningAverage = runningAverage + normalizedFlux[nValues]/nBins;
        message = "For bin " + i + " Normalized flux= " + d2s(normalizedFlux[nValues],6) + " running average= " + d2s(runningAverage,6);
        if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
        nValues = nValues + 1;
    };
//  Store the average normalized flux for each star in the avgNormFlux array
    avgNormFlux[k] = runningAverage;
    message = "Average normalized flux for " + STARlist[k] + "=" + avgNormFlux[k];
    if (STARtoDiagnose == "" || STARtoDiagnose == STARlist[k]) {successPrint = debugPrint(message,1);};
    successPrint = debugPrint(" ",1);
};
//
////****************** COMPUTE THE RMS FOR EACH STAR IN STARlist AND STORE IT IN THE STARrms ARRAY
//
STARrms = newArray(STARlistIndex);
for (k=0; k<STARlistIndex; k++) {
    iBegin = k*nBins;
    iEnd = (k+1)*nBins;
    varSum = 0.0;
    success = debugPrint("rms computation for star:" + STARlist[k],1);
    for (i=iBegin; i<iEnd; i++) {
      variance = (avgNormFlux[k]-normalizedFlux[i]) * (avgNormFlux[k]-normalizedFlux[i]);
      varSum = varSum + variance;
         };
    STARrms[k] = sqrt(varSum/nBins);
    message = " rms: " + STARrms[k];
    success = debugPrint (message,1);
};
//
//****************** ADD 99999 TO ANY RELATIVE, NORMALIZED FLUX VALUES GREATER
//                   THAN THE rmsLimitValue TIMES THE rms OF THAT STAR. ALSO
//                   FOR EACH STAR, KEEP A COUNT OF HOW MANY GOOD OBSERVATIONS
//                   THERE WERE
//
STARcount = newArray(STARlistIndex);
Array.fill(STARcount,0.0);
for (k=0; k<STARlistIndex; k++) {
    iBegin = k*nBins;
    iEnd = (k+1)*nBins;
    message = "For star: " + STARlist[k] + " rmsLimit*STARrms= " + d2s(rmsLimitValue*STARrms[k],4);
    success = debugPrint(message,1);
    for (i=iBegin; i<iEnd; i++) {
//  Add 99999 to the normalized flux (for later identification) if it is greater than
//  rmsLimitValue times the rms for this star; otherwise just increment count for number of
//  included observations for this star
        if (abs(1-normalizedFlux[i]) > rmsLimitValue * STARrms[k]) {
             message = "Exclude normalized flux of observation " + d2s(i-iBegin+1,0) + " normalizedFlux= " + normalizedFlux[i];
             success = debugPrint(message,1);
             normalizedFlux[i] = normalizedFlux[i] + 99999;
             } else {STARcount[k] = STARcount[k] + 1;};
    };
};
//
//****************** EXECUTE THE OPTIONS IN THIS ORDER: OPTION 2 PLOTS, OPTION 3 PLOT, OPTION 1
//
//
//                   FIRST, EXECUTE THIS CODE FOR ALL OPTIONS
message = "STARlistindex: " + d2s(STARlistIndex,1);
debugPrint(message,1);
STARpredDepth = newArray(STARlistIndex);
STARdisp = newArray(STARlistIndex);
//  Get the first row of observations for later use in getting
//  each star's Source-Sky count
index = indexArray[0];
rowString = fileArray[index];
for (k=0; k<STARlistIndex; k++) {
//  Compute depth needed for this NEB to mimic the target depth
     X = pow(10,-STARdmag[k]/2.50);
     NEBdepthPPT = predTargetDepth / X;
//   Store predicted for future use in Options 1 and 2
     STARpredDepth[k] = NEBdepthPPT;
//  Convert RMS to ppt and compute NEBdepthRMS
     NEBrmsPPT = STARrms[k]*1000;
     NEBdepthRMS = NEBdepthPPT / NEBrmsPPT;
//  Determine if star's Source-Sky count per pixel within the average aperature area
//  is less than 10; if so, the disposition should be ***Not Cleared-flux too low***
//  Get the weighted average Source-Sky count
    sourceSkyValue = STARSourceSky[k];
//  Determine notation indicating disposition and store disposition in STARdisp array
    STARdisp[k] = "***Not Cleared***";
     if (sourceSkyValue/apertureArea < 2) {
        STARdisp[k] = "***Not Cleared-flux too low***";
       } else {
               if (NEBdepthPPT >= 1000) {
                  STARdisp[k] = "Cleared-too faint";
                  } else {
                         if (NEBdepthRMS >= 5) {
                            STARdisp[k] = "Cleared";
                            } else {
                                   if (NEBdepthRMS <5 && NEBdepthRMS >= 3) {
                                      STARdisp[k] = "Likely cleared";
                                      };
                                   };
                         };
               };
};
//
//
//****************** CODE FOR OPTION 2
//
if (nebPlotOption) {
//
//  Create subdirectory name for plots that are to be saved as .png files
  subDirectoryPath = fileDir + "NEBcheck" + fileSeparator;
  File.makeDirectory(subDirectoryPath);
//
//  Start overlay 1 hour before ingress time and continue to 1 hour after egress time
  overlayStartTime = ingressTime - 1/24;
  overlayEndTime = egressTime + 1/24;
//  Set timeMIN to earlier of overlayStartTime or beginTimeRight
  if (overlayStartTime < beginTimeRight) {timeMIN = overlayStartTime;} else {timeMIN = beginTimeRight;};
//  Set timeMAX to later of overlayEndtime or endTimeRight
  if (overlayEndTime > endTimeRight) {timeMAX = overlayEndTime;} else {timeMAX = endTimeRight;};
//
//
//************************** Begin plot process

//  Create the Plot (X=time,Y=normalized relative flux)
//  For each star in STARlist, put into xValues and yValues the normalizedTime and
//  normalizedFlux values and then plot. For
//  the X axis, reuse the normalizedTime array for all stars
//
// First Create colar array and corresponding disposition cases
  colorChoice = newArray(5);
// Not cleared:
  colorChoice[0] = "red";
// Cleared - too faint:;
  colorChoice[1] = "black";
// Cleared:
  colorChoice[2] = "green";
// Likely cleared:
  colorChoice[3] = "orange";
// Not cleared - flux too low:
  colorChoice[4] = "pink";
//
// Cycle through each star to plot it's data and the transit curve
  for (k=STARlistIndex-1;k>=0; k--) {
//  Retrieve previously computed predicted depth for this star (see Option 1 code)
    predDepth = 1 - STARpredDepth[k]/1000;
// Load time and flux values for the k'th star into X and Y values
// and keep track of min and max flux
    iBegin = k*nBins;
    iEnd = (k+1)*nBins;
    jIndex = 0;
    fluxMIN = 2.0;
    fluxMAX = 0;
//  Create arrays for X and Y values to be plotted; use the values in STARcount for their size
    arraySize = STARcount[k];
    xValues = newArray(arraySize);
    yValues = newArray(arraySize);
    for (i=iBegin;i<iEnd;i++) {
//  Include the normalized flux value if it was previously determined to
//  be within RMS criteria, as well as the corresponding observation time
        if (normalizedFlux[i] < 99999) {
           xValues[jIndex] = binnedObsTimes[i-iBegin];
           message = "xValue calculated for: " + d2s(xValues[jIndex],6) + " observation time";
           success = debugPrint(message,1);
           yValues[jIndex] = normalizedFlux[i];
           jIndex = jIndex + 1;
           if (normalizedFlux[i] <= fluxMIN) {fluxMIN = normalizedFlux[i];};
           if (normalizedFlux[i] >  fluxMAX) {fluxMAX = normalizedFlux[i];};
           };
        
    };
    message = "timeMIN= " + timeMIN + " timeMAX= " + timeMAX + " fluxMIN= " + fluxMIN + " fluxMAX= " + fluxMAX;
    successPrint = debugPrint(message,1);
// Adjust min and max X values with 1% of X-range for better readability of the plot
    xMAX = timeMAX + 0.01*(timeMAX-timeMIN);
    xMIN = timeMIN - 0.01*(timeMAX-timeMIN);
// Use as maximum Y additional 25% of fluxMAX beyond 1.0; and use as minimum Y
// 10% of the minimum of (flux minimum or 1-transit depth) below 1.0
    yMAX = fluxMAX+ (fluxMAX-1)*0.25;
    if (fluxMIN < predDepth) {
        yMIN = fluxMIN -(1-fluxMIN)*0.1;
        } else { yMIN = predDepth - (1-predDepth)*0.1;};
// Create the the correct legends
    if (useBJD) {timeName = "BJD_TDB";} else {timeName = "JD_UTC";};
    Plot.create("Overlay of Required NEB Depth",timeName + " - " + d2s(beginTimeLeft,0),"relative normalized flux");
    Plot.setFrameSize(900,600);
    Plot.setLimits(xMIN,xMAX,yMIN,yMAX);
//  Put file name at a position 30% from the upper left corner
    Plot.addText(fullFileName,0.3,-0.05);
//  Put star name at a position 32% from the upper left corner
    Plot.addText("                              Star: " + STARlist[k],0.32,-0.006);
//  Put RMS, required depth, and dmag at a position 55% from the upper left corner
    Plot.addText("                RMS: " + d2s(STARrms[k]*1000,1) + " ppt      Required depth: " + d2s(STARpredDepth[k],1) + " ppt       dmag: " + d2s(STARdmag[k],1),0.55,-0.006);
//  Put star disposition at a position 28% from the upper corner, but below the above legend
    Plot.addText("                              Disposition: " + STARdisp[k],0.28,0.03);
//
//  Plot overlay of predicted depth
    Plot.setLineWidth(2);
// Use color corresponding to the star disposition for the data points
    if (STARdisp[k] == "***Not Cleared***") {
       nDisp = 0;
       } else {if (STARdisp[k] == "Cleared-too faint") {
                  nDisp = 1;
                  } else {if (STARdisp[k] == "Cleared") {
                             nDisp = 2;
                             } else {if (STARdisp[k] == "Likely cleared") {
                                         nDisp = 3;
                                         } else {nDisp = 4;};
                                    };
                         };
               };
//
    Plot.setColor(colorChoice[nDisp]);
//  Draw pre-ingress line
    Plot.drawLine(overlayStartTime,1.0,ingressTime,1.0);
//  Draw in-transit predicetd light curve
    Plot.drawLine(ingressTime,1.0,ingressTime,predDepth);
    Plot.drawLine(ingressTime,predDepth,egressTime,predDepth);
    Plot.drawLine(egressTime,predDepth,egressTime,1.0);
//  Draw post-egress line
    Plot.drawLine(egressTime,1.0,overlayEndTime,1.0);
//  Draw pred. ingress and egress legends
    Plot.setColor("blue");
    ingressTextX = (ingressTime-xMIN)/(xMAX-xMIN)-0.02;
    ingressTextY = (yMAX-predDepth)/(yMAX-yMIN)+0.03;
    Plot.addText(" Pred.",ingressTextX,ingressTextY);
    Plot.addText("Ingress",ingressTextX,ingressTextY+0.02);
    egressTextX = (egressTime-xMIN)/(xMAX-xMIN)-0.02;
    egressTextY = ingressTextY;
    Plot.addText(" Pred.",egressTextX,egressTextY);
    Plot.addText("Egress",egressTextX,egressTextY+0.02);
//
//  Plot data points in black
    Plot.setColor("black");
//  Plot the data points and then wait for user
    Plot.add("circles",xValues,yValues);
//  Plot only if user selected this option
    Plot.show();
    if (savePlots) {
//  Create the full output file name of the plot file;
//  include the measurement file name as the prefix
       pathOutputFile=subDirectoryPath + measurementFileName + "_" + STARlist[k] + "_NEBdepth_plot.png";
       save(pathOutputFile);
        };
  };
};
//
//
//****************** CODE FOR OPTIONS 3 AND 4
//
//
//  Create the Delta Magnitude vs. RMS Plot 
//  (X=dmag, Y=RMS) or (X=dmag, Y=log10 RMS)
//
if (dmagRMSOption) {
//
    nStars= STARlistIndex;
    dmagMIN =  100;
    dmagMAX = -100;
//  Set rmsMIN and rmsMAX correctly based on logPlot
    if (logPlot) {
        rmsMIN =  5;
        rmsMAX = -5;
        } else {
               rmsMIN = 100000;
               rmsMAX = -100000;
               };
//  Convert rms values to ppt
//  If user has selected log plot option, convert STARrms's to log10 basis;
//  either way, store RMS value to be plotted in STARrmsPlot array
    STARrmsPlot = newArray(STARlistIndex);
    for (i=0;i<nStars;i++) {
            STARrmsPlot[i] = STARrms[i] * 1000;
            message = "Star: " + i + " STARrms: " + STARrmsPlot[i];
            success = debugPrint(message,1);
            if (logPlot) {
//  Use natural log (base e) to compute log10(n), since log10(n) = log(n)/log(10)
                STARrmsPlot[i] = log(STARrmsPlot[i])/log(10);
                message = "Star: " + i + " STARrms: " + STARrmsPlot[i];
                success = debugPrint(message,1);
                };
    };
//
//  Find the min. and max. X and Y values
    for (i=0;i<nStars; i++) {
        if (STARdmag[i] <= dmagMIN) {dmagMIN = STARdmag[i];};
        if (STARdmag[i] >  dmagMAX) {dmagMAX = STARdmag[i];};
        if (STARrmsPlot[i] <= rmsMIN) {rmsMIN = STARrmsPlot[i];};
        if (STARrmsPlot[i] >  rmsMAX) {rmsMAX = STARrmsPlot[i];};
    };
// Adjust min and max values for better readability of the plot depending on type of plot
    if (logPlot) {
        rmsMAX = rmsMAX + 0.2;
        rmsMIN = rmsMIN - 0.2;
        } else {
          rmsMAX = rmsMAX + 50;
          rmsMIN = rmsMIN - 10;
          };
    dmagMIN = dmagMIN - 0.5;
    dmagMAX = dmagMAX + 0.5;
    message = "dmagMIN= " + dmagMIN + " dmagMAX= " + dmagMAX + " rmsMIN= " + rmsMIN + " rmsMAX= " + rmsMAX;
    successPrint = debugPrint(message,1);
//  Create appropriate axis labels based on logPlot
    if (logPlot) {
        Plot.create("dmag vs. (unbinned) RMS","dmag","log10 of RMS (ppt)");
        } else {Plot.create("dmag vs. (unbinned) RMS","dmag","RMS (ppt)");};
    Plot.setLimits(dmagMIN,dmagMAX,rmsMIN,rmsMAX);
//  Put file name at a position 30% from the upper left corner; include radius search if there was one
//  Force use of radius plot option
    radiusPlot = true;
    if (radiusPlot) {
       Plot.addText(fullFileName,0.3,-0.06);
       message = "                              Radius (arc-min): " + RADIUS;
       Plot.addText(message,0.3,-0.006);
       } else {
               Plot.addText(fullFileName,0.3,-0.02);
              };
//  Put into xValues and yValues the STARdmag and STARrms values up to the
//  number of stars
    xValues = newArray(nStars);
    yValues = newArray(nStars);
    for (i=0;i<nStars;i++) {
        xValues[i] = STARdmag[i];
        yValues[i] = STARrmsPlot[i];
        };
    Plot.add("x",xValues,yValues);
//  Plot star labels at the correct locations on the plot
    Plot.setJustification("center");
    for (i=0;i<nStars;i++) {
        X = (xValues[i]-dmagMIN)/(dmagMAX-dmagMIN);
        Y = (rmsMAX - yValues[i])/(rmsMAX-rmsMIN);
        message = "STARlist[i]: " + STARlist[i] + " X: " + d2s(X,1) + " Y: " + d2s(Y,1);
        successPrint = debugPrint(message,1);
        Plot.addText(STARlist[i],X,Y);
        };
    Plot.show;
//
//  Create the full output file name of the plot file;
//  include the measurement file name as the prefix
//
    pathOutputFile=fileDir + measurementFileName + "_dmagRMS_plot.png";
    save(pathOutputFile);
};

//
//
//****************** CODE FOR OPTION 1
//
if (nebTableOption){
//  Create the full output file name of the NEB Search Table file;
//  include the measurement file name as the prefix
  pathOutputFile=fileDir + measurementFileName + "_NEB_table" + ".txt";
//
//  Open the output file as a new file
//
  outputFile=File.open(pathOutputFile);
//
//  Create report title with date created and subject information
  File.append("                       TFOP NEB Search Table for:",pathOutputFile);
  File.append(CR,pathOutputFile);File.append(CR,pathOutputFile);
  File.append("           " + fullFileName,pathOutputFile);
  File.append(CR,pathOutputFile);File.append(CR,pathOutputFile);
  File.append("                 Created by AIJ macro Revision " + REVISION,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("                          on " + datetime,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("          ------------------------------------------------",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("                    Target predicted depth: " + DEPTH,pathOutputFile);
  File.append(CR,pathOutputFile);
  scaleString = d2s(nScale,2);
  File.append("                    Pixel Scale (arc-seconds/pixel): " + scaleString,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("                    Target Star: " + TARGET,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("                    Search Radius: " + RADIUS,pathOutputFile);
  File.append(CR,pathOutputFile);
  obsDurString = d2s(observationDuration,1);
  File.append("                    Duration of Observation (min.): " + obsDurString,pathOutputFile);
  File.append(CR,pathOutputFile);
  numObsString = d2s(nObservations,0);
  File.append("                    Number of Images: " + numObsString,pathOutputFile);
  File.append(CR,pathOutputFile);
  expString = d2s(averageExpPlusDelay,1);
  File.append("                    Average Exposure Plus Delay Time (sec.): " + expString,pathOutputFile);
  File.append(CR,pathOutputFile);
  cadenceString = d2s(requestedCadence,1);
  File.append("                    Cadence Requested When Calculating RMS (sec.): " + cadenceString,pathOutputFile);
  File.append(CR,pathOutputFile);
  binningString = d2s(binning,0);
  File.append("                    Binning Used When Calculating RMS: " + binningString,pathOutputFile);
  File.append(CR,pathOutputFile);
  apertureString = d2s(averageAPERTURE,1) + " (pixels); " + d2s(averageAPERTUREarcseconds,1) + " (arc-seconds)";
  File.append("                    Average Aperture Radius: " + apertureString,pathOutputFile);
  File.append(CR,pathOutputFile);File.append(CR,pathOutputFile);
  tableHeader ="      Separation";
  File.append(tableHeader,pathOutputFile);
  File.append(CR,pathOutputFile);
  tableHeader1 = "Star  from target  PA (deg.)  dmag   RMS(ppt)   NEBdepth(ppt)  NEBdepth/RMS   Disposition";
  File.append(tableHeader1,pathOutputFile);
  File.append(CR,pathOutputFile);
  debugPrint(tableHeader,1);
  debugPrint(tableHeader1,1);
//
//  Cycle through all stars in STARlist
  for (i=0; i<STARlistIndex; i++) {
//  Create NEB table entries for all stars except the target star
      if (STARlist[i] != TARGET) {
//  Get dmag value
         STARdmagValue = STARdmag[i];
//  Get minute part and seconds part of distance
         minutePart = floor(STARdist[i]/60);
         secondsPart = round(STARdist[i] - floor(STARdist[i]/60)*60);
//  If the seconds part = 60, make it 0 and add one to minute part
         if (secondsPart == 60) {secondsPart = 0; minutePart = minutePart + 1;};
         distanceMinutePart = d2s(minutePart,0);
         distanceSecondsPart = d2s(secondsPart,0);
//  If the seonds part is <10, add a "0" prefix to its character string equivalent
         if (secondsPart < 10) {distanceSecondsPart = "0" + distanceSecondsPart;};
         successPrint = debugPrint("For " + STARlist[i] + ": minute part=" + distanceMinutePart + " second part=" + distanceSecondsPart,1);
         separation = distanceMinutePart + singleQuote + distanceSecondsPart + doubleQuote;
         STARpaValue = STARpa[i];
//  If the name of the NEB is two characters, append a space to the front so its row lines up
//  with NEBs of three characters
         lenSTARlist = lengthOf(STARlist[i]);
         if (lenSTARlist == 2) {STARlist[i] = " " + STARlist[i];};
//  Convert STARpaValue, STARdmag, NEBrmsPPT, NEBdepthPPT to character strings
//  and then right justify them
         if (usePlateSolvedImage) {
             rightJustify(STARpaValue,0);
             STARpastring = globalValue;
             } else {
                     STARpastring ="  NA";
                     };
         rightJustify(STARdmagValue,3);
         STARdmagstring = globalValue;
         NEBdepthPPT = STARpredDepth[i];
//  Convert RMS to ppt and compute NEBdepthRMS
         NEBrmsPPT = STARrms[i]*1000;
         NEBdepthRMS = NEBdepthPPT / NEBrmsPPT;
         rightJustify(NEBrmsPPT,2);
         NEBrmsPPTstring = globalValue;
         rightJustify(NEBdepthPPT,1);
         NEBdepthPPTstring = globalValue;
         rightJustify(NEBdepthRMS,1);
         NEBdepthRMSstring = globalValue;
         notation = STARdisp[i];
         tableRow = STARlist[i] + "      " + separation + "     " + STARpastring + "   " + STARdmagstring + "   " + NEBrmsPPTstring + "        " + NEBdepthPPTstring + "      " + NEBdepthRMSstring + "        " + notation;
        File.append(tableRow,pathOutputFile);
        File.append(CR,pathOutputFile);
        debugPrint (tableRow,1);
   };
  };
//
//  Output explanation of various dispositions
  File.append(CR,pathOutputFile);
  File.append("Possible dispositions of the star being the source of the target predicted depth:",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("   Likely cleared (NEBdepth/RMS is between 3 and 5)",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("   Cleared (NEBdepth/RMS is >= 5)",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("   Cleared-too faint (NEBdepth >= 1000ppt)",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("   ***Not Cleared-flux too low*** (weighted average of Source-Sky counts per aperture pixel < 2)",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append("   ***Not Cleared*** (none of the above conditions are met)",pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append(CR,pathOutputFile);
//
//   Create rest of output file, namely the image shift calculations
//
//  Deterimine image shift statistics
//
//  Get the value in the user's file associated with each of the user-specified labels for:
//   1.  X(FITS)_TARGET
//   2.  Y(FITS)_TARGET
//  Assume that such labels and values are separated by the 
//  user-specified delimiter inputFileDelimiter
//
//  Cycle through each of the data rows in the user's file for the above values
//  Sum X(FITS)'s and Y(FITS)'s
  XFITS = newArray(nObservations);
  YFITS = newArray(nObservations);
  for (i=1; i<nObservations+1; i++) {
     rowString=fileArray[i];
     success=getData("X(FITS)_" + TARGET,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
     XFITS[i-1] = globalValue;
//
     success=getData("Y(FITS)_" + TARGET,header,rowString,inputFileDelimiter,firstMeasTableColFlag);
     YFITS[i-1] = globalValue;
  };
  Array.getStatistics(XFITS,minXFITS,maxXFITS,meanXFITS,stdDevXFITS);
  successPrint = debugPrint("min X(FITS)= " + minXFITS + " " + "max X(FITS)= " + maxXFITS + " " + "stdev X(FITS)=" +   stdDevXFITS,1);
  Array.getStatistics(YFITS,minYFITS,maxYFITS,meanYFITS,stdDevYFITS);
  successPrint = debugPrint("min Y(FITS)= " + minYFITS + " " + "max Y(FITS)= " + maxYFITS + " " + "stdev Y(FITS)=" +   stdDevYFITS,1);
//  Convert stdev's in pixels to arc-seconds based on SCALE;
  stdevX = nScale * stdDevXFITS;
  stdevY = nScale * stdDevYFITS;
  maxDevInX = maxXFITS-minXFITS;
  maxDevInY = maxYFITS-minYFITS;
//
//  Output image shift information
  shiftMessage1 = "Image shift statistics:";
  shiftMessage2 = "             stdev.(arc-seconds): " + stdevX + " in X and " + stdevY + " in Y";
  shiftMessage3 = "             max. deviation (pixels): " + maxDevInX + " in X and " + maxDevInY + " in Y";
//  nCount=nCount+1; sCount=d2s(nCount,0) + ".  ";
  File.append(shiftMessage1,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append(shiftMessage2,pathOutputFile);
  File.append(CR,pathOutputFile);
  File.append(shiftMessage3,pathOutputFile);
//
//  Close the output file
  File.close(outputFile);
};
//
//  Display appropriate dialogue message informing user of location of saved files
//
Dialog.create("");
if (nebTableOption && !dmagRMSOption) {
   Dialog.addMessage("The NEB Search Table can be found in:");
   Dialog.addMessage(fileDir);
   Dialog.addMessage("");
   };
if (dmagRMSOption && !nebTableOption) {
   Dialog.addMessage("The Dmag vs. RMS plot can be found in:");
   Dialog.addMessage(fileDir);
   Dialog.addMessage("");
   };
if (nebTableOption && dmagRMSOption) {;
   Dialog.addMessage("The NEB Search Table and Dmag vs. RMS plot can be found in:");
   Dialog.addMessage(fileDir);
   Dialog.addMessage("");
   };
if (nebPlotOption && savePlots) {
    Dialog.addMessage("The NEB predicted depth plots can be found in the following subdirectory:");
    Dialog.addMessage(subDirectoryPath);
    Dialog.addMessage("");
    };
if (nebTableOption || dmagRMSOption || (nebPlotOption && savePlots)) {
   Dialog.addMessage("                            NEB analysis completed!");
   } else {Dialog.addMessage("NEB analysis completed!");};
Dialog.show();
//
exit();
